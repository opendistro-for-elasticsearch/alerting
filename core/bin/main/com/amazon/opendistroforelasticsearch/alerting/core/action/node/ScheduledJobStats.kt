/*
 *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License").
 *   You may not use this file except in compliance with the License.
 *   A copy of the License is located at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   or in the "license" file accompanying this file. This file is distributed
 *   on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 *   express or implied. See the License for the specific language governing
 *   permissions and limitations under the License.
 */

package com.amazon.opendistroforelasticsearch.alerting.core.action.node

import com.amazon.opendistroforelasticsearch.alerting.core.JobSweeperMetrics
import com.amazon.opendistroforelasticsearch.alerting.core.resthandler.RestScheduledJobStatsHandler
import com.amazon.opendistroforelasticsearch.alerting.core.schedule.JobSchedulerMetrics
import org.elasticsearch.action.support.nodes.BaseNodeResponse
import org.elasticsearch.cluster.node.DiscoveryNode
import org.elasticsearch.common.io.stream.StreamInput
import org.elasticsearch.common.io.stream.StreamOutput
import org.elasticsearch.common.xcontent.ToXContent
import org.elasticsearch.common.xcontent.ToXContentFragment
import org.elasticsearch.common.xcontent.XContentBuilder

/**
 * Scheduled job stat that will be generated by each node.
 */
class ScheduledJobStats : BaseNodeResponse, ToXContentFragment {

    enum class ScheduleStatus(val status: String) {
        RED("red"),
        GREEN("green");

        override fun toString(): String {
            return status
        }
    }

    var status: ScheduleStatus
    var jobSweeperMetrics: JobSweeperMetrics? = null
    var jobInfos: Array<JobSchedulerMetrics>? = null

    constructor(si: StreamInput): super(si) {
        this.status = si.readEnum(ScheduleStatus::class.java)
        this.jobSweeperMetrics = si.readOptionalWriteable { JobSweeperMetrics(it) }
        this.jobInfos = si.readOptionalArray({ sti: StreamInput -> JobSchedulerMetrics(sti) }, { size -> arrayOfNulls(size) })
    }

    constructor(
        node: DiscoveryNode,
        status: ScheduleStatus,
        jobSweeperMetrics: JobSweeperMetrics?,
        jobsInfo: Array<JobSchedulerMetrics>?
    ) : super(node) {
        this.status = status
        this.jobSweeperMetrics = jobSweeperMetrics
        this.jobInfos = jobsInfo
    }

    companion object {
        @JvmStatic
        fun readScheduledJobStatus(si: StreamInput) = ScheduledJobStats(si)
    }

    override fun writeTo(out: StreamOutput) {
        super.writeTo(out)
        out.writeEnum(status)
        out.writeOptionalWriteable(jobSweeperMetrics)
        out.writeOptionalArray(jobInfos)
    }

    override fun toXContent(builder: XContentBuilder, params: ToXContent.Params): XContentBuilder {
        builder.field("name", node.name)
        builder.field("schedule_status", status)
        builder.field("roles", node.roles.map { it.roleName().toUpperCase() })
        if (jobSweeperMetrics != null) {
            builder.startObject(RestScheduledJobStatsHandler.JOB_SCHEDULING_METRICS)
            jobSweeperMetrics!!.toXContent(builder, params)
            builder.endObject()
        }

        if (jobInfos != null) {
            builder.startObject(RestScheduledJobStatsHandler.JOBS_INFO)
            for (job in jobInfos!!) {
                builder.startObject(job.scheduledJobId)
                job.toXContent(builder, params)
                builder.endObject()
            }
            builder.endObject()
        }
        return builder
    }
}
